"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var Tokenizer = _interopRequire(require("./Tokenizer"));

var TOKENS = require("./Tokens").TOKENS;

var Node = _interopRequire(require("./Nodes/Node"));

var AtRule = _interopRequire(require("./Nodes/AtRule"));

var Block = _interopRequire(require("./Nodes/Block"));

var Comment = _interopRequire(require("./Nodes/Comment"));

var DocumentRoot = _interopRequire(require("./Nodes/DocumentRoot"));

var Declaration = _interopRequire(require("./Nodes/Declaration"));

var Ruleset = _interopRequire(require("./Nodes/Ruleset"));

/**
 * @class Parser
 *
 * The parser analyzes the the tokens passed from the tokenizer,
 * and builds an abstract syntax tree (AST) that linters can use.
 */

var Parser = (function () {
    function Parser() {
        _classCallCheck(this, Parser);

        /**
         * The tokens passed from the Tokenizer.
         * @type {Array}
         */
        this.tokens = [];

        /**
         * The AST. This is where we store AST nodes as we construct the tree.
         * @type {Array}
         */
        this.ast = new DocumentRoot();

        /**
         * Marks the current position in the AST. This is where we add child nodes to.
         * @type {Node}
         */
        this.current = this.ast;

        /**
         * The last node that was added to the tree. This is where we attach whitespace to.
         * @type {Node}
         */
        this.latest = this.ast;

        /**
         * Index of the current token being consumed.
         * @type {number}
         */
        this.pos = -1;
    }

    _createClass(Parser, {
        parse: {

            /**
             * Parse an array of tokens.
             * @param {string} scss
             * @param {object} options
             */

            value: function parse(scss) {
                var options = arguments[1] === undefined ? {} : arguments[1];

                // Start a new tokenizer
                var tokenizer = new Tokenizer();

                if (options && options.bench) {
                    console.time("tokenize");
                }

                // Use the Tokenizer to parse SCSS string into an array of tokens.
                this.tokens = tokenizer.tokenize(scss);

                if (options && options.bench) {
                    console.timeEnd("tokenize");
                    console.time("parse");
                }

                //Loop through tokens & parse.
                var token = undefined;
                while (token = this.nextToken()) {
                    this.parseToken(token);
                }

                if (options && options.bench) {
                    console.timeEnd("parse");
                }

                return this.ast;
            }
        },
        nextToken: {
            value: function nextToken() {
                if (this.pos === this.tokens.length) {
                    return false;
                }this.pos++;

                return this.tokens[this.pos];
            }
        },
        peek: {
            value: function peek() {
                if (this.pos === this.tokens.length) {
                    return false;
                }return this.tokens[this.pos + 1];
            }
        },
        expect: {
            value: function expect(type) {
                return this.peek().type === type;
            }
        },
        prevToken: {
            value: function prevToken() {
                if (this.pos === 0) {
                    return false;
                }this.pos--;

                return this.tokens[this.pos];
            }
        },
        parseToken: {
            value: function parseToken(token) {
                switch (token.type) {
                    case TOKENS.whitespace:
                        this.attachWhitespace(token.lexeme);
                        break;

                    case TOKENS.atSymbol:
                        this.parseAtRule(token);
                        break;

                    case TOKENS.period:
                    case TOKENS.dollar:
                    case TOKENS.hash:
                    case TOKENS.word:
                    case TOKENS.dash:
                    case TOKENS.openBracket:
                    case TOKENS.asterisk:
                    case TOKENS.percent:
                        this.parseStatement(token);
                        break;

                    case TOKENS.multilineComment:
                    case TOKENS.comment:
                        this.parseComment(token);
                        break;

                    default:
                        this.throwException(token);
                        break;
                }
            }
        },
        addNode: {

            /**
             * Attach a child to the current node & set as latest.
             * @param node
             */

            value: function addNode(node) {
                this.current.attachChild(node);
                node.parent = this.current;
                node.previousNode = this.latest;

                this.latest = node;
            }
        },
        setParent: {

            /**
             * Set a node as the current "parent" node that nodes should be added to.
             * @param node
             */

            value: function setParent(node) {
                this.current = node;
            }
        },
        unsetParent: {

            /**
             * Unset current parent, moving back up towards the root of the AST.
             */

            value: function unsetParent() {
                var newParent = this.current.parent;

                if (newParent) {
                    this.current = newParent;
                    this.latest = newParent;
                }
            }
        },
        throwException: {

            /**
             * Throw an exception when the parser finds an unexpected token.
             * @TODO: This could use some friendlier reporting.
             * @param token
             * @param expected
             */

            value: function throwException(token, expected) {
                function ParserException() {
                    this.name = "ParserException";
                    this.message = "Unexpected input token " + token.type + " at " + token.source.line + ":" + token.source.column + ".";

                    if (expected) {
                        this.message += " Expected " + expected + ".";
                    }
                }

                throw new ParserException();
            }
        },
        attachWhitespace: {

            /**
             * Attach whitespace to previous rule.
             */

            value: function attachWhitespace(whitespace) {
                this.latest.after += whitespace;
            }
        },
        parseAtRule: {

            /**
             * Attempt to parse an at-rule node.
             */

            value: function parseAtRule(token) {
                var atRule = new AtRule(token);

                this.addNode(atRule);

                atRule.value = "";

                var child = undefined;
                while (child = this.nextToken()) {
                    if (child.type === TOKENS.whitespace) {
                        atRule.between = child.lexeme;
                    } else if (child.type === TOKENS.string || child.type === TOKENS.hash || child.type === TOKENS.dollar || child.type === TOKENS.percent || child.type === TOKENS.dash || child.type === TOKENS.underscore || child.type === TOKENS.plus || child.type === TOKENS.period || child.type === TOKENS.colon || child.type === TOKENS.comma || child.type === TOKENS.word || child.type === TOKENS.openParen || child.type === TOKENS.closeParen) {
                        // Handle interpolation... e.g. #{$variable}
                        if (child.type === TOKENS.hash && this.peek().type === TOKENS.openCurlyBracket) {
                            atRule.value += this.readInterpolation(child);
                        } else {
                            atRule.value += child.lexeme;
                        }
                    } else if (child.type === TOKENS.atSymbol) {
                        this.setParent(atRule);
                        this.parseAtRule(child);
                        this.unsetParent();
                        break;
                    } else if (child.type === TOKENS.openCurlyBracket) {
                        this.setParent(atRule);
                        this.parseBlock(child);
                        this.unsetParent();
                        break;
                    } else if (child.type === TOKENS.semicolon) {
                        atRule.after += ";";
                        break;
                    } else {
                        this.throwException(child);
                    }
                }
            }
        },
        readInterpolation: {

            /**
             * Attempt to read an interpolation & return its text.
             * e.g. #{$variable}
             */

            value: function readInterpolation(token) {
                var text = "#";

                var next = undefined;
                while (next = this.nextToken()) {
                    text += next.lexeme;

                    // On the next closing curly bracket, leave the interpolation.
                    if (next.type === TOKENS.closeCurlyBracket) {
                        break;
                    }
                }

                return text;
            }
        },
        parseStatement: {

            /**
             * Attempt to parse a statement.
             * @TODO Is this the right terminology? Should this exist in AST?
             */

            value: function parseStatement(token) {
                var text = "";

                do {
                    if (token.type === TOKENS.openCurlyBracket) {
                        // We're entering a block, so this must be a rule.
                        this.parseRuleset(token, token, text);
                        break;
                    } else if (token.type === TOKENS.hash) {
                        // We found a hash, which might be either an ID or interpolation...
                        if (this.peek().type === TOKENS.openCurlyBracket) {
                            text += this.readInterpolation(token);
                        } else {
                            text += token.lexeme;
                        }
                    } else if (token.type === TOKENS.semicolon) {
                        // We found a semicolon, so this must be a declaration.
                        this.parseDeclaration(token, text);
                        break;
                    } else if (token.type === TOKENS.closeCurlyBracket && text.length) {
                        // We found a closing curly with an unterminated declaration before it
                        this.parseDeclaration(token, text, false);
                        break;
                    } else {
                        text += token.lexeme;
                    }
                } while (token = this.nextToken());
            }
        },
        parseRuleset: {

            /**
             * Parse a ruleset "selector { ... }"
             * @param token
             * @param block
             * @param selector
             */

            value: function parseRuleset(token, block, selector) {
                var ruleset = new Ruleset(token, selector);

                this.addNode(ruleset);
                this.setParent(ruleset);

                this.parseBlock(block);

                this.unsetParent();
            }
        },
        parseDeclaration: {

            /**
             * Parse a declaration "property: value;"
             * @param token
             * @param text
             * @param terminated
             */

            value: function parseDeclaration(token, text) {
                var terminated = arguments[2] === undefined ? true : arguments[2];

                var separator = text.indexOf(":");
                var property = text.substring(0, separator);
                var value = text.substring(separator + 1);

                var declaration = new Declaration(token, property, value);
                if (terminated) {
                    declaration.after += ";";
                }

                this.addNode(declaration);
            }
        },
        parseBlock: {

            /**
             * Parse a block "{ ... }".
             * @param token
             */

            value: function parseBlock(token) {
                var block = new Block(token);
                this.addNode(block);

                this.setParent(block);

                var child = undefined;
                while (child = this.nextToken()) {
                    if (child.type === TOKENS.closeCurlyBracket) {
                        break;
                    } else if (child.type === TOKENS.openCurlyBracket) {
                        this.parseBlock(child);
                    } else {
                        this.parseToken(child);
                    }
                }

                this.unsetParent();
            }
        },
        parseComment: {

            /**
             * Parse comment token into an AST node.
             * @param token
             */

            value: function parseComment(token) {
                var comment = new Comment(token);
                this.addNode(comment);
            }
        }
    });

    return Parser;
})();

module.exports = Parser;