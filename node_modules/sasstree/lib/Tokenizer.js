"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var _Tokens = require("./Tokens");

var CHARS = _Tokens.CHARS;
var TOKENS = _Tokens.TOKENS;

var _util = require("./util");

var isWhitespace = _util.isWhitespace;
var isNewline = _util.isNewline;
var isLetter = _util.isLetter;
var isDigit = _util.isDigit;

/**
 * @class Tokenizer
 *
 * The tokenizer breaks string input into a series of tokens (lexical
 * analysis), which it passes off to the parser.
 */

var Tokenizer = (function () {
    function Tokenizer() {
        _classCallCheck(this, Tokenizer);

        /**
         * The string being tokenized.
         * @type {string}
         */
        this.string = "";

        /**
         * The tokens!
         * @type {array}
         */
        this.tokens = [];

        /**
         * Offset from the beginning of the string.
         * @type {number}
         */
        this.pos = 0;

        /**
         * The beginning of the current column.
         * @type {number}
         */
        this.offset = 0;

        /**
         * The line of CSS we're parsing.
         * @type {number}
         */
        this.line = 1;
    }

    _createClass(Tokenizer, {
        pushCharacterToken: {

            /**
             * Add a token to the tokens array.
             * @param token
             * @param lexeme
             */

            value: function pushCharacterToken(token, lexeme) {
                this.tokens.push({
                    type: token,
                    lexeme: lexeme,
                    source: {
                        line: this.line,
                        column: this.pos - this.offset
                    }
                });
            }
        },
        pushBlockToken: {

            /**
             * Add a multi-character token to the tokens array.
             * @param token
             * @param lexeme
             * @param startPos
             * @param startOffset
             * @param startLine
             */

            value: function pushBlockToken(token, lexeme, startPos, startOffset, startLine) {
                this.tokens.push({
                    type: token,
                    lexeme: lexeme,
                    source: {
                        start: {
                            line: startLine,
                            column: startPos - startOffset,
                            offset: startOffset
                        },
                        end: {
                            line: this.line,
                            column: this.pos - this.offset,
                            offset: this.offset
                        }
                    }
                });
            }
        },
        nextChar: {

            /**
             * Return next character in string input, or false.
             * @param string
             * @returns {number} character code
             */

            value: function nextChar(string) {
                if (this.pos === string.length) {
                    return false;
                }return string.charCodeAt(this.pos);
            }
        },
        tokenize: {

            /**
             * Given a SCSS string, return its tokens.
             * @param string
             * @returns {array}
             */

            value: function tokenize(string) {
                var char = undefined;

                // Remove UTF Byte Order Mark
                string = string.replace(/^\uFEFF/, "");

                // Save the string we're tokenizing for future reference.
                this.string = string;

                // Iterate through characters and tokenize.
                while (char = this.nextChar(string)) {
                    // If we hit a newline, increment line number & update offset.
                    if (char == CHARS.newline) {
                        this.offset = this.pos;
                        this.line += 1;
                    }

                    // Tokenize by comparing character codes (because it's way way faster
                    // than either regex or string comparison).
                    switch (char) {
                        case CHARS.space:
                        case CHARS.tab:
                        case CHARS.newline:
                        case CHARS.carriageReturn:
                        case CHARS.formFeed:
                            this.tokenizeWhiteSpace();
                            break;

                        case CHARS.colon:
                            this.pushCharacterToken(TOKENS.colon, ":");
                            break;

                        case CHARS.semicolon:
                            this.pushCharacterToken(TOKENS.semicolon, ";");
                            break;

                        case CHARS.comma:
                            this.pushCharacterToken(TOKENS.comma, ",");
                            break;

                        case CHARS.openBracket:
                            this.pushCharacterToken(TOKENS.openBracket, "[");
                            break;

                        case CHARS.closeBracket:
                            this.pushCharacterToken(TOKENS.closeBracket, "]");
                            break;

                        case CHARS.openCurlyBracket:
                            this.pushCharacterToken(TOKENS.openCurlyBracket, "{");
                            break;

                        case CHARS.closeCurlyBracket:
                            this.pushCharacterToken(TOKENS.closeCurlyBracket, "}");
                            break;

                        case CHARS.openParen:
                            this.pushCharacterToken(TOKENS.openParen, "(");
                            break;

                        case CHARS.closeParen:
                            this.pushCharacterToken(TOKENS.closeParen, ")");
                            break;

                        case CHARS.singleQuote:
                        case CHARS.doubleQuote:
                            this.tokenizeQuotedString();
                            break;

                        case CHARS.ampersand:
                            this.pushCharacterToken(TOKENS.ampersand, "&");
                            break;

                        case CHARS.exponent:
                            this.pushCharacterToken(TOKENS.exponent, "^");
                            break;

                        case CHARS.dash:
                            this.pushCharacterToken(TOKENS.dash, "-");
                            break;

                        case CHARS.bang:
                            this.pushCharacterToken(TOKENS.bang, "!");
                            break;

                        case CHARS.dollar:
                            this.pushCharacterToken(TOKENS.dollar, "$");
                            break;

                        case CHARS.percent:
                            this.pushCharacterToken(TOKENS.percent, "%");
                            break;

                        case CHARS.atSymbol:
                            this.tokenizeAtSymbol();
                            break;

                        case CHARS.hash:
                            this.pushCharacterToken(TOKENS.hash, "#");
                            break;

                        case CHARS.plus:
                            this.pushCharacterToken(TOKENS.plus, "+");
                            break;

                        case CHARS.tilde:
                            this.pushCharacterToken(TOKENS.tilde, "~");
                            break;

                        case CHARS.equals:
                            this.pushCharacterToken(TOKENS.equals, "=");
                            break;

                        case CHARS.greaterThan:
                            this.pushCharacterToken(TOKENS.greaterThan, ">");
                            break;

                        case CHARS.period:
                            this.pushCharacterToken(TOKENS.period, ".");
                            break;

                        case CHARS.asterisk:
                            this.pushCharacterToken(TOKENS.asterisk, "*");
                            break;

                        case CHARS.underscore:
                            this.pushCharacterToken(TOKENS.underscore, "_");
                            break;

                        default:
                            // Parse comments first by halting on '/*' or '//'
                            var nextChar = string.charCodeAt(this.pos + 1);
                            if (char === CHARS.forwardSlash && nextChar === CHARS.asterisk) {
                                this.tokenizeMultilineComment();
                                break;
                            }

                            if (char === CHARS.forwardSlash && nextChar === CHARS.forwardSlash) {
                                this.tokenizeComment();
                                break;
                            }

                            if (char === CHARS.forwardSlash) {
                                this.pushCharacterToken(TOKENS.forwardSlash, char);
                                break;
                            }

                            if (char === CHARS.backslash && nextChar === CHARS.nine) {
                                this.pushCharacterToken(TOKENS.hack, "\\9");
                                break;
                            }

                            if (isLetter(char)) {
                                this.tokenizeWord();
                                break;
                            }

                            if (isDigit(char)) {
                                this.tokenizeInteger();
                                break;
                            }

                            console.error("Unrecognized token at " + this.line + ":" + (this.pos - this.offset) + " --> " + this.string.charAt(this.pos));

                            break;
                    }

                    this.pos++;
                }

                return this.tokens;
            }
        },
        tokenizeMultilineComment: {

            /**
             * Find multiline comment tokens.
             */

            value: function tokenizeMultilineComment() {
                var next = this.pos + 1;
                var char = undefined;
                var nextChar = undefined;

                var _pos = this.pos;
                var _offset = this.offset;
                var _line = this.line;

                do {
                    next++;
                    char = this.string.charCodeAt(next);
                    nextChar = this.string.charCodeAt(next + 1);

                    if (char == CHARS.newline) {
                        this.offset = next;
                        this.line += 1;
                    }
                } while (!(char === CHARS.asterisk && nextChar === CHARS.forwardSlash));

                this.pushBlockToken(TOKENS.multilineComment, this.string.slice(this.pos, next + 2), _pos, _offset, _line);

                this.pos = next + 1;
            }
        },
        tokenizeComment: {

            /**
             * Find single-line comment tokens.
             */

            value: function tokenizeComment() {
                var next = this.pos;
                var char = undefined;

                do {
                    next++;
                    char = this.string.charCodeAt(next);
                } while (char !== CHARS.newline);

                this.pushCharacterToken(TOKENS.comment, this.string.slice(this.pos, next));
                this.pos = next - 1;
            }
        },
        tokenizeWhiteSpace: {

            /**
             * Find whole whitespace tokens.
             */

            value: function tokenizeWhiteSpace() {
                var next = this.pos;
                var char = undefined;

                do {
                    next++;
                    char = this.string.charCodeAt(next);

                    if (isNewline(char)) {
                        this.offset = next;
                        this.line += 1;
                    }
                } while (isWhitespace(char));

                this.pushCharacterToken(TOKENS.whitespace, this.string.slice(this.pos, next));
                this.pos = next - 1;
            }
        },
        tokenizeWord: {

            /**
             * Find whole word tokens.
             */

            value: function tokenizeWord() {
                var next = this.pos;
                var char = undefined;

                do {
                    next++;
                    char = this.string.charCodeAt(next);
                } while (isLetter(char));

                this.pushCharacterToken(TOKENS.word, this.string.slice(this.pos, next));
                this.pos = next - 1;
            }
        },
        tokenizeQuotedString: {

            /**
             * Find quoted string tokens.
             */

            value: function tokenizeQuotedString() {
                var quote = this.string.charCodeAt(this.pos);
                var quoteChar = quote === CHARS.singleQuote ? "'" : "\"";
                var next = this.pos;
                var escaped = undefined;

                do {
                    escaped = false;
                    next = this.string.indexOf(quoteChar, next + 1);

                    // If there's no matching quote, throw a tokenizer error.
                    if (next === -1) throw new Error("Unclosed quote: " + quoteChar);

                    // Is the char before the next matching quote a backslash? If so, is
                    // _that_ backslash escaped by a backlash(...)? If it's a valid escaped quote
                    // char, restart the loop so we can find the following quote and test it.
                    var escapePos = next;
                    while (this.string.charCodeAt(escapePos - 1) === CHARS.backslash) {
                        escapePos -= 1;
                        escaped = !escaped;
                    }
                } while (escaped);

                this.pushCharacterToken(TOKENS.string, this.string.slice(this.pos, next + 1));
                this.pos = next;
            }
        },
        tokenizeAtSymbol: {

            /**
             * Tokenize an at-word symbol.
             *
             * For example:
             *   `@charset "UTF-8";`
             *   `@font-face { ... }`
             */

            value: function tokenizeAtSymbol() {
                var next = this.pos;
                var char = undefined;

                // At-symbols are followed by a keyword, and then either a string or block.

                do {
                    next++;
                    char = this.string.charCodeAt(next);
                } while (!(isWhitespace(char) || char == CHARS.openParen || char == CHARS.openCurlyBracket || char == CHARS.semicolon));

                this.pushCharacterToken(TOKENS.atSymbol, this.string.slice(this.pos, next));
                this.pos = next - 1;
            }
        },
        tokenizeInteger: {

            /**
             * Find integer tokens.
             */

            value: function tokenizeInteger() {
                var next = this.pos;
                var char = undefined;

                do {
                    next++;
                    char = this.string.charCodeAt(next);
                } while (isDigit(char));

                this.pushCharacterToken(TOKENS.word, this.string.slice(this.pos, next));
                this.pos = next - 1;
            }
        }
    });

    return Tokenizer;
})();

module.exports = Tokenizer;